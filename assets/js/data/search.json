[ { "title": "생성자", "url": "/posts/constructor/", "categories": "programming, kotlin", "tags": "programming, kotlin", "date": "2022-10-13 04:40:00 +0900", "snippet": "kotlin에서는 클래스이름 옆에 소괄호를 붙여서 생성자를 만든다.생성자가 없을때class NewsItemDtoclass NewsItemDto { }kotlin에서는 class의 body가 없을 경우에는 java에서 처럼 {}로 감싸지 않아도 됨인자가 없는 생성자class NewsItemDto()kotlin에서의 인자가 여러개인 생성자data class NewsItemDto ( var title: String, var link: String)java에서의 인자가 여러개인 생성자class NewsItemDto {\tString title;\tString link;\t\tNewsItemDto(String title, String link) {\t\tthis.title = title;\t\tthis.link = link;\t}}" }, { "title": "class와 data class 차이", "url": "/posts/dataClass/", "categories": "programming, kotlin", "tags": "programming, kotlin", "date": "2022-10-13 04:00:00 +0900", "snippet": "classclass NewsItemDto ( var title: String, var originallink: String, var link: String, var description: String, var pubDate: String)data classdata class NewsItemDto ( var title: String, var originallink: String, var link: String, var description: String, var pubDate: String)class 앞에 data 키워드를 붙이게 되면 프로퍼티들에 대한 아래의 함수들이 컴파일 시점에 자동으로 생성된다. data를 보관하는 목적인 class에 사용한다. getter() setter() equals() hashCode() toString() copy()" }, { "title": "백준 1912번_연속합_java", "url": "/posts/acmicpc-1912/", "categories": "programming, acmicpc", "tags": "programming, acmicpc", "date": "2022-08-26 21:38:00 +0900", "snippet": "문제풀이동적계획법을 이용 동적계획법 : 특정 범위까지의 값을 구하기 위해 그것과 다른 범위의 값을 이용해서 효율적으로 구하는 방법아래의 조건을 모두 만족할 경우에는 i번째 위치까지의 연속합은 i-1번째 위치까지의 연속합과 i번째 값의 합 (i-1번째 까지의 합이 양수 &amp;&amp; i-1번째 까지의 연속합과 i번째 값의 합이 양수일 경우) 이외의 경우는 i번째 까지의 연속합은 i번째 값으로추가로 dp[i] &lt; dp[i-1] 일 수 있으므로 dp[i] 값과 max값을 비교하는 로직 필요 ex) 10 -4 dp[0] = 10 dp[1] = 6코드package acmicpc;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.stream.Stream;public class acmicpc1912 {\tpublic static void main(String[] agrs) {\t\ttry {\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\t\t\tint n = Integer.parseInt(reader.readLine());\t\t\tint numArr[] = Stream.of(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\t\t\t\t\t\tint dp[] = new int[n];\t\t\tdp[0] = numArr[0];\t\t\tint max = dp[0];\t\t\t\t\t\tfor(int i=1; i&lt;n; i++) {\t\t\t\tif(dp[i-1] &gt; 0 &amp;&amp; dp[i-1] + numArr[i] &gt; 0) {\t\t\t\t\tdp[i] = dp[i-1] + numArr[i];\t\t\t\t} else {\t\t\t\t\tdp[i] = numArr[i];\t\t\t\t}\t\t\t\t\t\t\t\tif(max &lt; dp[i]) {\t\t\t\t\tmax = dp[i];\t\t\t\t}\t\t\t}\t\t\t\t\t\twriter.append(String.valueOf(max));\t\t\twriter.flush();\t\t\twriter.close();\t\t} catch (Exception e) {\t\t\t\t\t}\t}\t}" }, { "title": "백준 25305번_커트라인_java", "url": "/posts/acmicpc-25305/", "categories": "programming, acmicpc", "tags": "programming, acmicpc", "date": "2022-08-16 12:54:00 +0900", "snippet": "문제풀이배열을 내림차순 정렬 후 k번째 index의 요소를 구함코드package acmicpc;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.Arrays;import java.util.Comparator;public class acmicpc25305 {\tpublic static void main(String[] agrs) {\t\ttry {\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\t\t\t\t\t\tint[] intArr = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\t\t\tint n = intArr[0];\t\t\tint k = intArr[1];\t\t\t\t\t\tString[] strArr = reader.readLine().split(\" \");\t\t\tInteger intArr2[] = new Integer[n];\t\t\tfor(int i=0; i&lt;strArr.length; i++) {\t\t\t\tintArr2[i] = Integer.parseInt(strArr[i]); \t\t\t}\t\t\tArrays.sort(intArr2, Comparator.reverseOrder());\t\t\t\t\t\twriter.append(String.valueOf(intArr2[k-1]));\t\t\twriter.flush();\t\t\twriter.close();\t\t} catch (Exception e) {\t\t\t\t\t}\t}}" }, { "title": "색인 생성", "url": "/posts/index/", "categories": "etc, google_search_console", "tags": "etc, google_search_console", "date": "2022-08-12 18:24:00 +0900", "snippet": "github io에는 페이지가 푸쉬되었지만 구글 검색에 노출이 되지 않아 google search console 사이트를 확인하니 아래의 이미지처럼 제외됨으로 표시됨최종 크롤링이 해당사항 없음으로 표시되는것은 구글 봇이 페이지를 발견했지만 아직 크롤링이 되지 않은 상태 시간이 흐르면 자동으로 크롤링 되지만 수동으로 크롤링 신청이 가능URL을 클릭 후 URL 검사를 클릭하면 색인이 생성됬는지 확인할 수 있고 색인생성을 요청할 수 있음색인 생성 요청을 클릭" }, { "title": "백준 25304번_영수증_java", "url": "/posts/acmicpc-25304/", "categories": "programming, acmicpc", "tags": "programming, acmicpc", "date": "2022-08-08 22:25:00 +0900", "snippet": "문제코드package acmicpc;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.Arrays;public class acmicpc25304 {\tpublic static void main(String[] agrs) {\t\ttry {\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\t\t\t\t\t\tint x = Integer.parseInt(reader.readLine());\t\t\tint n = Integer.parseInt(reader.readLine());\t\t\t\t\t\tint sum = 0;\t\t\tfor(int i=0; i&lt;n; i++) {\t\t\t\tint[] intArr = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\t\t\t\tsum = sum + intArr[0] * intArr[1];\t\t\t}\t\t\t\t\t\twriter.append(sum == x ? \"Yes\" : \"No\"); \t\t\twriter.flush();\t\t\twriter.close();\t\t} catch (Exception e) {\t\t\t\t\t}\t}}" }, { "title": "백준 3003번_킹, 퀸, 룩, 비숍, 나이트, 폰_java", "url": "/posts/acmicpc-3003/", "categories": "programming, acmicpc", "tags": "programming, acmicpc", "date": "2022-08-08 22:04:00 +0900", "snippet": "문제접근방식각 피스의 개수 + 더하거나 빼야 되는 피수 수 = 체스에서 각 피스의 수코드package acmicpc;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.Arrays;public class acmicpc3003 {\tpublic static void main(String[] agrs) {\t\ttry {\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\t\t\t\t\t\tint[] intArr = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\t\t\tint[] piece = {1, 1, 2, 2, 2, 8};\t\t\t\t\t\tfor(int i=0; i&lt;intArr.length; i++) {\t\t\t\twriter.append(String.valueOf(piece[i] - intArr[i]) + \" \");\t\t\t}\t\t\t\t\t\twriter.flush();\t\t\twriter.close();\t\t} catch (Exception e) {\t\t\t\t\t}\t}}" }, { "title": "백준 24416번_알고리즘 수업 - 피보나치 수 1_java", "url": "/posts/acmicpc-24416/", "categories": "programming, acmicpc", "tags": "programming, acmicpc", "date": "2022-07-27 11:47:00 +0900", "snippet": "문제정리* 재귀public static int fib_recursion(int n) {\tcnt++;\tif(n == 1 || n == 2) {\t\treturn 1;\t} else {\t\treturn fib_recursion(n-1) + fib_recursion(n-2);\t}\t}자기자신을 반복해서 호출 f(n)을 구하기 위해 f(n-1), f(n-2)를 구하고 f(n-1), f(n-2)는 다시 쪼개지면서 f를 다시 호출하지 않을때까지 반복하는 방식(하향식) fib(5) = fib(4) + fib(3) 　　　= fib(3) + fib(2) + fib(3) = fib(2) + fib(1) + fib(2) + fib(2) + fib(1) 　　　= 3*fib(2) + 2*fib(1) fib(4) = fib(3) + fib(2) fib(3) = fib(2) + fib(1) n=5 일 경우 함수 호출 9번 발생 n=30 일 경우 함수 1664079번 호출* DP(Dynamic Programming)public static int fib_dp(int n) {\tint[] dp = new int[n+1];\t\tdp[1] = 1;\tdp[2] = 1;\t\tfor(int i=3; i&lt;=n; i++) {\t\tcnt++;\t\tdp[i] = dp[i-1] + dp[i-2];\t}\t\treturn dp[n];}동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장해서 동일한 계산의 반복 수행을 제거하는 방법 1부터 n까지 올라가면서 각 단계의 값을 메모리에 저장해서 다음 단계의 값을 구할때 사용(상향식) dp[3] = dp[2] + dp[1] = 1 + 1 = 2 dp[4] = dp[3] + dp[2] = 2 + 1 = 3 dp[5] = dp[4] + dp[3] = 3 + 2 = 5 n=5 일 경우 for문 3번 반복 n=30 일 경우 for문 28 반복코드package acmicpc;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class acmicpc24416 {\tstatic int cnt = 0;\tpublic static void main(String[] agrs) {\t\ttry {\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\t\t\t\t\t\tint n = Integer.parseInt(reader.readLine());\t\t\t\t\t\tfib_recursion(n);\t\t\twriter.append(String.valueOf(cnt) + \" \");\t\t\tcnt=0;\t\t\tfib_dp(n);\t\t\twriter.append(String.valueOf(cnt));\t\t\t\t\t\twriter.flush();\t\t\twriter.close();\t\t} catch (Exception e) {\t\t\t\t\t}\t}\t\tpublic static int fib_recursion(int n) {\t\tif(n == 1 || n == 2) {\t\t\tcnt++;\t\t\treturn 1;\t\t} else {\t\t\treturn fib_recursion(n-1) + fib_recursion(n-2);\t\t}\t\t\t}\t\tpublic static int fib_dp(int n) {\t\tint[] dp = new int[n+1];\t\t\t\tdp[1] = 1;\t\tdp[2] = 1;\t\t\t\tfor(int i=3; i&lt;=n; i++) {\t\t\tcnt++;\t\t\tdp[i] = dp[i-1] + dp[i-2];\t\t}\t\t\t\treturn dp[n];\t}}" }, { "title": "백준 2004번_조합 0의 개수_java", "url": "/posts/acmicpc-2004/", "categories": "programming, acmicpc", "tags": "programming, acmicpc", "date": "2022-07-27 00:59:00 +0900", "snippet": "문제접근방식끝자리가 0이 되기 위해서는 10의 배수여야 하고 10의 배수는 2의배수 이면서 5의 배수이다. n이 250일 경우 5를 약수로 가지는 개수는 아래의 표와 같이 5의 배수의 수 + 25의 배수의 개수 + 125의 배수의 개수의 합과 같다.5 25 = 5*5 125 = 5*5*5\t\t5\t10\t15\t20\t25\t50\t125\t250\t\t\t5의 배수\t\t1\t\t1\t\t1\t\t1\t\t1\t\t1\t\t1\t\t1\t\t\t\t25의 배수\t\t\t\t\t\t\t\t\t\t1\t\t1\t\t1\t\t1\t\t\t\t125의 배수\t\t\t\t\t\t\t\t\t\t\t\t\t\t1\t\t1\t250!의 5를 약수로 가지는 수는 위의 표를 참고하면 250/5 + 250/25 + 250/125가 된다. 결과값은 (n!의 5를 약수로 가지는 수 - r!의 5를 약수로 가지는 수 - (n-r)!의 5를 약수로 가지는 수) 와 (n!의 2를 약수로 가지는 수 - r!의 2를 약수로 가지는 수 - (n-r)!의 2를 약수로 가지는 수) 중에 최소값을 구하면 된다.코드package acmicpc;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.Arrays;public class acmicpc2004 {\tpublic static void main(String[] agrs) {\t\ttry {\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\t\t\t\t\t\tint intArr[] = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\t\t\tint n = intArr[0];\t\t\tint m = intArr[1];\t\t\tint answer[][] = {{n, 0, 0}, {n-m, 0, 0}, {m, 0, 0}}; //num, 5 약수개수, 2 약수개수\t\t\tint cnt = 0;\t\t\t\t\t\tif(m &gt;= 1) {\t\t\t\tfor(int i=0; i&lt;3; i++) {\t\t\t\t\tint num = answer[i][0];\t\t\t\t\tcnt = 0;\t\t\t\t\tint jisu = 1;\t\t\t\t\t\t\t\t\t\t//5 약수개수\t\t\t\t\twhile(true) {\t\t\t\t\t\tint quotient = num / (int)Math.pow(5, jisu++);\t\t\t\t\t\tif(quotient &gt; 0) {\t\t\t\t\t\t\tcnt += quotient;\t\t\t\t\t\t} else {\t\t\t\t\t\t\tanswer[i][1] = cnt;\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\tcnt = 0;\t\t\t\t\tjisu = 1;\t\t\t\t\t\t\t\t\t\t//2 약수개수\t\t\t\t\twhile(true) {\t\t\t\t\t\tint quotient = num / (int)Math.pow(2, jisu++);\t\t\t\t\t\tif(quotient &gt; 0) {\t\t\t\t\t\t\tcnt += quotient;\t\t\t\t\t\t} else {\t\t\t\t\t\t\tanswer[i][2] = cnt;\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t\t\t\t\t\twriter.append(String.valueOf(Math.min(answer[0][1] - answer[1][1] - answer[2][1], answer[0][2] - answer[1][2] - answer[2][2])));\t\t\t} else if(m &lt; 1) {\t\t\t\twriter.append(String.valueOf(cnt));\t\t\t}\t\t\t\t\t\twriter.flush();\t\t\twriter.close();\t\t} catch (Exception e) {\t\t\t\t\t}\t}}" }, { "title": "백준 1676번_팩토리얼 0의 개수_java", "url": "/posts/acmicpc-1676/", "categories": "programming, acmicpc", "tags": "programming, acmicpc", "date": "2022-07-26 09:18:00 +0900", "snippet": "문제접근방식뒤에 0이 나올려면 10의 배수여야 하고 10=2*5 이므로 N!의 값이 2를 약수로 가지는 횟수와 5를 약수로 가는지 횟수 중에 최소값을 구하면 된다. 2를 약수로 가지는 횟수보다 5를 약수로 가지는 횟수가 작으므로 N!이 5를 약수로 가지는 횟수를 구하면 된다.코드package acmicpc;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class acmicpc1676 {\tpublic static void main(String[] agrs) {\t\ttry {\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\t\t\t\t\t\tint n = Integer.parseInt(reader.readLine());\t\t\tint cnt = 0;\t\t\t\t\t\tfor(int i=1; i&lt;=n; i++) {\t\t\t\tint a = i; \t\t\t\t\t\t\t\twhile(true) {\t\t\t\t\tint remain = a%5;\t\t\t\t\tif(remain &gt; 0) {\t\t\t\t\t\tbreak;\t\t\t\t\t} else {\t\t\t\t\t\ta = a/5;\t\t\t\t\t\tcnt++;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t\t\t\twriter.append(String.valueOf(cnt));\t\t\twriter.flush();\t\t\twriter.close();\t\t} catch (Exception e) {\t\t\t\t\t}\t}}" }, { "title": "백준 9375번_패션왕 신해빈_java", "url": "/posts/acmicpc-9375/", "categories": "programming, acmicpc", "tags": "programming, acmicpc", "date": "2022-07-25 19:14:00 +0900", "snippet": "문제접근방식의상종류(상의, 신발…) 당 선택가능한 케이스는 그 의상의 케이스+1(해당 의상종류 미선택) 의상을 입을 수 있는 케이스는 각 의상 종류의 케이스+1의 곱들에 1을 뺀 값(모두 미선택 할 경우) 1번 테스트 케이스의 경우 아래의 표와 같이 총 6개의 케이스 중에서 모두 미선택 하는 경우만 빠짐 (eyewear 종류+1)*(headgear 종류+1)-1 = 2*3-1 = 5\teyewear\theadgear\t\t\tx\t\tx\t\t\t\tx\t\that\t\t\t\tx\t\tturban\t\t\t\tsunglasses\t\tx\t\t\t\tsunglasses\t\that\t\t\t\tsunglasses\t\tturban \t코드package acmicpc;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.HashMap;import java.util.Map;public class acmicpc9375 {\tpublic static void main(String[] agrs) {\t\ttry {\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\t\t\t\t\t\tint num = Integer.parseInt(reader.readLine());\t\t\tfor(int i=0; i&lt;num; i++) {\t\t\t\tint n = Integer.parseInt(reader.readLine());\t\t\t\tMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\t\t\t\tfor(int j=0; j&lt;n; j++) {\t\t\t\t\tString strArr[] = reader.readLine().split(\" \");\t\t\t\t\tString key = strArr[1];\t\t\t\t\t\t\t\t\t\tif(map.containsKey(key)) {\t\t\t\t\t\tmap.put(key, map.get(key)+1); \t\t\t\t\t} else {\t\t\t\t\t\tmap.put(key, 1);\t\t\t\t\t}\t\t\t\t}\t\t\t\t\t\t\t\tint cnt = 1;\t\t\t\tfor(String key : map.keySet()) {\t\t\t\t\tcnt = cnt * (map.get(key)+1);\t\t\t\t}\t\t\t\twriter.append(String.valueOf(cnt-1)+\"\\n\");\t\t\t}\t\t\t\t\t\twriter.flush();\t\t\twriter.close();\t\t} catch (Exception e) {\t\t\t\t\t}\t}}" } ]
